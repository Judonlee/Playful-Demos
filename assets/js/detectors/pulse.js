/*
 * Pulse Detector Library
 * http://www.happyworm.com
 *
 * Copyright (c) 2014 Happyworm Ltd
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 *
 * Author: Mark J Panaghiston
 * Version: 0.0.1
 * Date: 9th May 2014
 *
 * Standing on the shoulders of giants
 * Camille Teicheira
 * https://github.com/camilleanne/biofeedback
 *
 * Requires: underscore.js
 */

(function(PM, _) {

	var DEBUG = true;

	var Pulse = function(options) {
		this.init(options);
	};

	if(typeof PM === 'undefined') {
		window.Pulse = Pulse; // 
	} else {
		PM.Pulse = function(options) {
			return new Pulse(options); // 
		};
	}

	// Maths Functions

	function mean(array) {
		var sum = array.reduce(function(a, b){ return a + b });
		return sum/array.length;
	}

	function normalize(array){
		// normalizes an array of data to a mean of zero (does not normalize between -1 and 1)
		var square = [];
		var normalized = [];
		var averageOfArray = mean(array);

		//standard deviation
		for (var i = 0; i < array.length; i++){
			square.push(Math.pow((array[i] - averageOfArray), 2));
		};
		
		var squaredAverage = mean(square);
		var stdDev = Math.sqrt(squaredAverage);

		//normalize
		for (var i = 0; i < array.length; i++){
			normalized.push((array[i] - averageOfArray)/stdDev)
		};
		
		return normalized;
	}

	function frequencyExtract(fftArray, framerate){
		// Return the Discrete Fourier Transform sample frequencies.
		// returns the center of the FFT bins
		// blantantly ripped from numpy.fft.fftfreq(), but ported by JS by yours truly
		
		var val, n, d, N;
		var p1 = [];
		var p2 = [];
		var results = [];
		var freqs = [];

		//from numpy.fft.fftfreq doc: "Sample spacing (inverse of the sampling rate). Defaults to 1. For instance, if the sample spacing is in seconds, then the frequency unit is cycles/second."
		// if my frequency is 15 fps, or 15 Hz, or every 66ms, then the sample spacing is .066 seconds (1/15)

		n = fftArray.length;
		d = 1.0/framerate;

		val = 1.0/(n * d);
		N = ((n - 1)/2 + 1) >> 0;
		for (var i = 0; i < N; i++){ p1.push(i) }
		for (var i = (-(n/2) >> 0); i < 0; i++) { p2.push(i) }
		results = p1.concat(p2);
		freqs = results.map( function(i){ return i * val });

		return filterFreq(fftArray, freqs, framerate);
	}

	function filterFreq(fftArray, freqs, framerate){
		// calculates the power spectra and returns 
		// the frequency, in Hz, of the most prominent 
		// frequency between 0.75 Hz and 3.3333 Hz (45 - 200 bpm)
		var filteredFFT = [];
		var filteredFreqBin = [];

		var freqObj = _.object(freqs, fftArray);
		for (freq in freqObj){
			if ((freq > 0.80) && (freq < 3)){
				filteredFFT.push(freqObj[freq]);
				filteredFreqBin.push((freq)/1);
			}
		}
		var normalizedFreqs = filteredFFT.map(function(i) {return Math.pow(Math.abs(i), 2)});
		var idx = _.indexOf(normalizedFreqs, _.max(normalizedFreqs));
		var freq_in_hertz = filteredFreqBin[idx];
		
		freqs = {normalizedFreqs: normalizedFreqs, filteredFreqBin: filteredFreqBin, freq_in_hertz: freq_in_hertz}
		return freqs;
	}

	Pulse.prototype = {
		init: function(options) {
			// The default options
			this.options = {
				id: '', // The id of messages being broadcast.
				target: null,
				url: "ws://immense-lake-7450.herokuapp.com/echo",
				width: 400,
				height: 300,
				fps: 15,
				bufferWindow: 512,
				averageOver: 5
			};
			// Read in instancing options.
			for(var option in options) {
				if(options.hasOwnProperty(option)) {
					this.options[option] = options[option];
				}
			}
			this.target = typeof this.options.target === 'string' ? document.querySelector(this.options.target) : this.options.target;

			this.sendingData = false;

			this.red = [];
			this.green = [];
			this.blue = [];

			this.heartrate = 60;
			this.bpm = this.heartrate;
			this.averager = [];

			this.initWebSocket();
			this.initVideo();
			this.start();
		},
		broadcast: function(type) {
			// Broadcast the message
			if(PM) {
				PM.broadcast(type, {
					id: this.options.id,
					target: this,
					msg: 'Generated by: Pulse'
				});
			}
		},
		initWebSocket: function() {
			var self = this;
			var dataSocket = this.dataSocket = new WebSocket(this.options.url);

			dataSocket.onopen = function() {
				if(DEBUG) console.log("websocket open!");
			};

			dataSocket.onmessage =  function(e) {
				var data = JSON.parse(e.data);
				if (data.id === "ICA") {
					self.cardiac(data.array, data.bufferWindow);
				}
			};

			dataSocket.onclose = function() {
				if(DEBUG) console.log('closed');
			};
		},
		sendData: function(data) {
			if(this.dataSocket) {
				this.dataSocket.send(data);
			}
		},
		initVideo: function() {
			this.videoElem = document.createElement("video");
			this.videoElem.setAttribute("width", this.options.width);
			this.videoElem.setAttribute("height", this.options.height);

			// camera
			this.cameraCanvas = document.createElement("canvas");
			this.cameraCanvas.setAttribute("width", this.options.width);
			this.cameraCanvas.setAttribute("height", this.options.height);
			this.cameraCanvas.className = 'camera';
			this.cameraContext = this.cameraCanvas.getContext("2d");

			this.overlayCanvas = document.createElement("canvas");
			this.overlayCanvas.setAttribute("width", this.options.width);
			this.overlayCanvas.setAttribute("height", this.options.height);
			this.overlayCanvas.className = 'overlay';
			this.overlayContext = this.overlayCanvas.getContext("2d");

			this.target.appendChild(this.cameraCanvas);
			this.target.appendChild(this.overlayCanvas);
		},
		start: function() {
			var self = this;
			if(!this.htrackr) {
				this.htrackr = new headtrackr.Tracker({
					detectionInterval: 1000 / this.options.fps,
					ui: false
				});
				this.htrackr.init(this.videoElem, this.cameraCanvas);
				document.addEventListener("facetrackingEvent", function(event) {
					self.analyse(event);
				});
			}
			this.htrackr.start();

			this.sendingDataId = setInterval(function() {
				if(self.sendingData) {
					self.sendData(JSON.stringify({"array": [self.red, self.green, self.blue], "bufferWindow": self.green.length}));
				}
			}, 1000);

		},
		stop: function() {
			if(this.htrackr) {
				this.htrackr.stop();
			}
			clearInterval(this.sendingDataId);
		},
		analyse: function(event) {
			var ctx = this.overlayContext;
			ctx.clearRect(0, 0, this.options.width, this.options.height);

			//  ** CS == camshift (in headtrackr.js) ** 
			//  ** once we have stable tracking, draw rectangle ** 
			if (event.detection == "CS") {
				ctx.rotate(event.angle-(Math.PI/2));
				ctx.strokeStyle = "#00CC00";
				ctx.strokeRect((event.x - (event.width/2)) >> 0, (event.y - (event.height/2)) >> 0, event.width, event.height);
			}





			var sx, sy, sw, sh, forehead, inpos, outpos;
			var greenSum = 0;
			var redSum = 0;
			var blueSum = 0;

			// ** approximating forehead based on facetracking ** 
			sx = event.x + (-(event.width/5)) + 20 >> 0;
			sy = event.y + (-(event.height/3)) + 10 >> 0;
			sw = (event.width/5) >> 0;
			sh = (event.height/10) >> 0;

			//  ** for debugging: blue forehead box ** 
			ctx.strokeStyle = "#33CCFF";       
			ctx.strokeRect(sx, sy, sw, sh);

			forehead = this.cameraContext.getImageData(sx, sy, sw, sh);

			for (i = 0; i < forehead.data.length; i+=4) {
				// ** for reference: ** 
				// var red = forehead.data[i];
				// var green = forehead.data[i+1];
				// var blue = forehead.data[i+2];
				// var alpha = forehead.data[i+3];

				redSum = forehead.data[i] + redSum;
				greenSum = forehead.data[i+1] + greenSum;
				blueSum = forehead.data[i+2] + blueSum;
			}

			var redAverage = redSum/(forehead.data.length/4);
			var greenAverage = greenSum/(forehead.data.length/4);
			var blueAverage = blueSum/(forehead.data.length/4);

			if (this.green.length < this.options.bufferWindow){
				this.red.push(redAverage);
				this.green.push(greenAverage);
				this.blue.push(blueAverage);
				if (this.green.length > this.options.bufferWindow/8){
					this.sendingData = true;
				}
			} else {
				this.red.push(redAverage);
				this.red.shift();
				this.green.push(greenAverage);
				this.green.shift();
				this.blue.push(blueAverage);
				this.blue.shift();
			}

			ctx.rotate((Math.PI/2)-event.angle);
		},
		cardiac: function(spectrum, bfwindow) {
			var freqs = frequencyExtract(spectrum, this.options.fps);
			var freq = freqs.freq_in_hertz;
			this.heartrate = freq * 60;

			this.averager.push(this.heartrate);
			if(this.averager.length > this.options.averageOver){
				this.averager.shift();
				this.bpm = Math.round(mean(this.averager));
			}

			this.broadcast('pulseupdate');
		}
	};
	return Pulse;
}(window.PM, window._));
