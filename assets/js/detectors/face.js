/*
 * Face Detector Library
 * http://www.happyworm.com
 *
 * Copyright (c) 2014 Happyworm Ltd
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 *
 * Author: Mark J Panaghiston
 * Version: 0.0.1
 * Date: 20th May 2014
 *
 * Requires:
 * headtrackr.js (https://github.com/auduno/headtrackr/)
 */

(function(PM) {

	var DEBUG = true;

	var Face = function(options) {
		this.init(options);
	};

	if(typeof PM === 'undefined') {
		window.Face = Face; // 
	} else {
		PM.Face = function(options) {
			return new Face(options); // 
		};
	}

	Face.prototype = {
		init: function(options) {
			// The default options
			this.options = {
				id: '', // The id of messages being broadcast.
				target: null,
				width: 400,
				height: 300,
				overlay: true
			};
			// Read in instancing options.
			for(var option in options) {
				if(options.hasOwnProperty(option)) {
					this.options[option] = options[option];
				}
			}
			this.target = typeof this.options.target === 'string' ? document.querySelector(this.options.target) : this.options.target;

			this.initVideo();
			// this.start();
		},
		broadcast: function(type, event) {
			// Broadcast the message
			if(PM) {
				PM.broadcast(type, {
					id: this.options.id,
					target: this,
					event: event,
					msg: 'Generated by: Face'
				});
			}
		},
		initVideo: function() {
			this.videoElem = document.createElement("video");
			this.videoElem.setAttribute("width", this.options.width);
			this.videoElem.setAttribute("height", this.options.height);

			this.cameraCanvas = document.createElement("canvas");
			this.cameraCanvas.setAttribute("width", this.options.width);
			this.cameraCanvas.setAttribute("height", this.options.height);
			this.cameraCanvas.className = 'camera';
			this.cameraContext = this.cameraCanvas.getContext("2d");

			this.overlayCanvas = document.createElement("canvas");
			this.overlayCanvas.setAttribute("width", this.options.width);
			this.overlayCanvas.setAttribute("height", this.options.height);
			this.overlayCanvas.className = 'overlay';
			this.overlayContext = this.overlayCanvas.getContext("2d");

			this.target.appendChild(this.cameraCanvas);
			this.target.appendChild(this.overlayCanvas);
		},
		start: function(options) {
			var self = this;
			if(!this.htrackr) {
				this.htrackr = new headtrackr.Tracker(options);
				this.htrackr.init(this.videoElem, this.cameraCanvas);
				document.addEventListener("facetrackingEvent", function(event) {
					if(self.options.overlay) {
						self.update(event);
					}
					self.broadcast("faceupdate", event);
				});
				document.addEventListener("headtrackingEvent", function(event) {
					self.broadcast("headupdate", event);
				});
				document.addEventListener("headtrackrStatus", function(event) {
					if(event.status === 'tick') {
						self.broadcast("usermedia_update", event);
					} else {
						self.broadcast("facestatus", event);
					}
				});
			}
			this.htrackr.start();
		},
		stop: function() {
			if(this.htrackr) {
				this.htrackr.stop();
			}
		},
		update: function(event) {
			var ctx = this.overlayContext;
			ctx.clearRect(0, 0, this.options.width, this.options.height);

			// once we have stable tracking, draw rectangle
			if (event.detection == "CS") {
				ctx.translate(event.x, event.y)
				ctx.rotate(event.angle-(Math.PI/2));
				ctx.strokeStyle = "#00CC00";
				ctx.strokeRect((-(event.width/2)) >> 0, (-(event.height/2)) >> 0, event.width, event.height);
				ctx.rotate((Math.PI/2)-event.angle);
				ctx.translate(-event.x, -event.y);
				// proximity.innerHTML = event.width*event.height;
				// angle.innerHTML = (Math.PI/2)-event.angle;
			}
		}
	};
}(window.PM));
