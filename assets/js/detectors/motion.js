/*
 * Motion Detector Library
 * http://www.happyworm.com
 *
 * Copyright (c) 2014 Happyworm Ltd
 * Licensed under the MIT license.
 * http://opensource.org/licenses/MIT
 *
 * Author: Mark J Panaghiston
 * Version: 0.0.1
 * Date: 21st May 2014
 *
 * Requires:
 * headtrackr.js (https://github.com/auduno/headtrackr/)
 */

(function(PM) {

	var DEBUG = false;

	var Motion = function(options) {
		this.init(options);
	};

	if(typeof PM === 'undefined') {
		window.Motion = Motion; // 
	} else {
		PM.Motion = function(options) {
			return new Motion(options); // 
		};
	}

	Motion.prototype = {
		init: function(options) {
			// The default options
			this.options = {
				id: '', // The id of messages being broadcast.
				target: null,
				width: 400,
				height: 300,
				threshold_pixel: 60, // Out of 255
				threshold: 0.05 // Out of 1
			};
			// Read in instancing options.
			for(var option in options) {
				if(options.hasOwnProperty(option)) {
					this.options[option] = options[option];
				}
			}
			this.target = typeof this.options.target === 'string' ? document.querySelector(this.options.target) : this.options.target;

			this.firstTime = true;

			this.previousData = null;
			this.currentData = null;
			this.outputData = null;

			this.initCanvas();
			this.start();
		},
		broadcast: function(type, event) {
			// Broadcast the message
			if(PM) {
				PM.broadcast(type, {
					id: this.options.id,
					target: this,
					event: event,
					msg: 'Generated by: Motion'
				});
			}
		},
		initCanvas: function() {
			this.motionCanvas = document.createElement("canvas");
			this.motionCanvas.setAttribute("width", this.options.width);
			this.motionCanvas.setAttribute("height", this.options.height);
			this.motionCanvas.className = 'motion';
			this.motionContext = this.motionCanvas.getContext("2d");

			this.target.appendChild(this.motionCanvas);
		},
		start: function() {
			var self = this;

			var measure = function(diff) {
				var fired = 255;
				if(diff > self.options.threshold_pixel) {
					return fired;
				} else if(diff < -self.options.threshold_pixel) {
					return fired;
				} else {
					return 0;
				}
			};

			if(PM) {
				PM.listen('usermedia_update', function(data) {
					var media = data.target;
					self.previousData = self.currentData;
					self.currentData = data.target.cameraContext.getImageData(0, 0, data.target.options.width, data.target.options.height);
					if(self.firstTime) {
						self.firstTime = false;
					} else {
						self.outputData = self.motionContext.createImageData(self.currentData.width, self.currentData.height);
						self.motionSum = {
							red:0,
							green:0,
							blue:0
						};
						for(var i = 0, iLen = self.currentData.data.length; i < iLen; i+=4) {
							var rDiff = measure(self.currentData.data[i] - self.previousData.data[i]);
							var gDiff = measure(self.currentData.data[i+1] - self.previousData.data[i+1]);
							var bDiff = measure(self.currentData.data[i+2] - self.previousData.data[i+2]);
							var aDiff = measure(self.currentData.data[i+3] - self.previousData.data[i+3]);

							self.outputData.data[i] = rDiff;
							self.outputData.data[i+1] = gDiff;
							self.outputData.data[i+2] = bDiff;

							self.motionSum.red += rDiff;
							self.motionSum.green += gDiff;
							self.motionSum.blue += bDiff;

							if(rDiff || gDiff || bDiff) {
								self.outputData.data[i+3] = 255;
							} else {
								self.outputData.data[i+3] = 0;
							}
						}
						var factorToRatio = 4 / self.currentData.data.length / 255;
						self.motionAvg = {
							red: self.motionSum.red * factorToRatio,
							green: self.motionSum.green * factorToRatio,
							blue: self.motionSum.blue * factorToRatio
						};
						self.motion = (self.motionAvg.red + self.motionAvg.green + self.motionAvg.blue) / 3;
						self.motionContext.putImageData(self.outputData, 0, 0);

						if(DEBUG) console.log('[usermedia_update] | red: ' + self.motionAvg.red + ' | green: ' + self.motionAvg.green + ' | blue: ' + self.motionAvg.blue + ' | motion: ' + self.motion);

						if(self.motion > self.options.threshold) {
							self.broadcast('motion');
						}
/*
			forehead = this.cameraContext.getImageData(sx, sy, sw, sh);

			for (i = 0; i < forehead.data.length; i+=4) {
				// ** for reference: ** 
				// var red = forehead.data[i];
				// var green = forehead.data[i+1];
				// var blue = forehead.data[i+2];
				// var alpha = forehead.data[i+3];

				redSum = forehead.data[i] + redSum;
				greenSum = forehead.data[i+1] + greenSum;
				blueSum = forehead.data[i+2] + blueSum;
			}

			var redAverage = redSum/(forehead.data.length/4);
			var greenAverage = greenSum/(forehead.data.length/4);
			var blueAverage = blueSum/(forehead.data.length/4);
*/

					}
				});
			}
		},
		stop: function() {
		},
		update: function(event) {
		}
	};
}(window.PM));
